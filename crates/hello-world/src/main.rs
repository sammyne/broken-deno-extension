use std::path::PathBuf;

use clap::Parser;
use deno::x;
use deno::x::url;
use deno_core::anyhow::Context as _;
use deno_runtime::deno_core::anyhow;
use deno_runtime::worker::{MainWorker, WorkerOptions};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let args = Cli::parse();

    let module_url = resolve_path(&args.js_path).context("resolve module url")?;

    let service_options = new_worker_service_options();
    let worker_options = WorkerOptions {
        startup_snapshot: Some(SNAPSHOT),
        ..Default::default()
    };

    let mut worker = MainWorker::bootstrap_from_options(&module_url, service_options, worker_options);
    worker
        .execute_main_module(&module_url)
        .await
        .context("exec main module")?;
    worker.run_event_loop(false).await.context("run event loop")
}

#[derive(Parser)]
struct Cli {
    /// 待执行的 JS 文件路径。
    #[clap(short, long, default_value = "static/app.js")]
    js_path: PathBuf,
}

// Load the snapshot generated by build.rs:
static SNAPSHOT: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/DENO_EXT_QUICKSTART.snapshot"));


pub type Sys = sys_traits::impls::RealSys;

pub fn new_worker_service_options() -> WorkerServiceOptions<DenoInNpmPackageChecker, NpmResolver<Sys>, Sys> {
    let fs = Arc::new(RealFs);
    let permission_desc_parser = Arc::new(RuntimePermissionDescriptorParser::new(Sys {}));
    let permissions = PermissionsContainer::allow_all(permission_desc_parser);

    WorkerServiceOptions::<DenoInNpmPackageChecker, NpmResolver<Sys>, Sys> {
        blob_store: Default::default(),
        broadcast_channel: Default::default(),
        deno_rt_native_addon_loader: None,
        feature_checker: Default::default(),
        fs,
        module_loader: Rc::new(FsModuleLoader),
        node_services: Default::default(),
        npm_process_state_provider: Default::default(),
        permissions,
        root_cert_store_provider: Default::default(),
        fetch_dns_resolver: Default::default(),
        shared_array_buffer_store: Default::default(),
        compiled_wasm_module_store: Default::default(),
        v8_code_cache: Default::default(),
    }
}

pub fn resolve_path(p: &Path) -> anyhow::Result<Url> {
    let p = if p.is_absolute() {
        p.to_owned()
    } else {
        std::env::current_dir().context("get current dir")?.join(p)
    };

    let out = ModuleSpecifier::from_file_path(p).map_err(|_| anyhow::anyhow!("load js file"))?;

    Ok(out)
}

